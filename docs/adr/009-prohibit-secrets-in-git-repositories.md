# ADR-009: Prohibit Secrets in Git Repositories

**Date:** 2025-11-06  
**Status:** Accepted  
**Deciders:** Platform Engineering  
**Context:** All Layers (k8s-boot → k8s-core → applications)  

## Context

The platform follows a **pure GitOps** model: every cluster’s state is derived from Git.  
However, this creates tension between *declarative configuration* and *sensitive data management*.  

Most of the credentials required by Kubernetes workloads do **not** originate inside Kubernetes at all.  
They are generated by external systems — cloud consoles, SaaS dashboards, or command-line tools — such as:

- DNS provider API tokens for `cert-manager` and `external-dns`  
- GitHub or GitLab Personal Access Tokens for FluxCD  
- Route 53, S3, or GCP access keys  
- Service-to-service API keys, webhook tokens, or OAuth client secrets  

These keys are typically shown **only once at creation time**, after which the issuing console or CLI never displays them again.  
They must therefore be captured and stored immediately in a **secure external vault** such as **1Password**, AWS Secrets Manager, or HashiCorp Vault — *not* in Git.  

Historically, teams have tried to preserve such keys by checking them into repositories in one of these forms:

- Plaintext Kubernetes Secrets  
- Encrypted YAML via **SOPS** or **Sealed Secrets**  
- Base64-encoded placeholders committed “just for testing”  

All of these approaches embed sensitive material—whether plaintext or ciphertext—into source control, creating rotation overhead, exposure risk, and unnecessary complexity.  

Since **External Secrets Operator (ESO)** (see ADR-003) provides a way to pull credentials directly from vaults, secrets no longer need to live in Git at all.

## Decision

**No Git repository managed by the platform may contain secret material, encrypted or plaintext.**

Git repositories may only contain:

- **`SecretStore` / `ClusterSecretStore`** definitions describing external backends  
- **`ExternalSecret`** resources mapping remote keys to Kubernetes Secrets  
- **References** to secret names, not their values  

The only exception is the **initial bootstrap Secret** that grants ESO access to its backend (for example, a 1Password Service Account token).  
That Secret must be created manually via `kubectl create secret` and must never be committed to Git.

## Rationale

| Concern | Traditional “secrets-in-Git” | Platform Policy |
|----------|------------------------------|-----------------|
| **Origin of secrets** | Keys copied from cloud consoles and pasted into YAML | Keys stored once in secure vaults such as 1Password |
| **Rotation & Revocation** | Requires re-encrypting / re-committing | Handled entirely by backend |
| **Audit Surface** | Secret material persists in history | Git contains only metadata |
| **Tooling Complexity** | GPG, SOPS, or Sealed Secrets per environment | None — vaults + ESO only |
| **Automation** | Manual encrypt/decrypt steps | Declarative sync via ESO |

This mirrors **ADR-002 (Disable Flux Helm Controller)**: both remove mutation of sensitive state and keep clusters reproducible, declarative, and air-gap-friendly.

## Consequences

### Positive
- Zero secret data in Git history → simpler audits and backups  
- Unified, declarative pattern for all secrets using ESO  
- Easier onboarding — no encryption tooling required  
- Safe repository mirroring or open-sourcing (no embedded secrets)  

### Negative
- Requires at least one external secret backend (1Password, Vault, AWS SM, etc.)  
- ESO must be operational before dependent controllers start  
- One manual bootstrap Secret per cluster  

##  Implementation Guidelines
- All templates must reference Secrets via `ExternalSecret`.   
- Bootstrap scripts may read vault credentials from local CLIs (e.g. `op cli`) but never write them to disk or Git.  

## 6 Alternatives Considered

| Option | Description | Outcome |
|---------|--------------|----------|
| **SOPS + Flux** | Encrypt values in Git | Rejected – no vault integration |
| **ESO + No-Secrets-in-Git (chosen)** | Secrets live only in backends | ✅ Accepted |

## 7 References

- [ADR-001 Layered Platform Model](./001-layered-platform.md)  
- [ADR-002 Choose FluxCD as GitOps Engine](./002-choose-fluxcd-as-gitops-engine.md)  
- [ADR-003 Choose External Secrets Operator](./003-choose-external-secrets-operator.md)  
- [External Secrets Operator Docs](https://external-secrets.io/)  
- [1Password Service Account Integration](https://developer.1password.com/docs/cli/kubernetes/)  

**Decision Summary:**  
All platform repositories must contain **zero secrets** — no plaintext, no ciphertext, no encoded data.  
Most secrets originate as API keys or credentials created on external consoles or CLIs; these must be stored immediately in a secure vault such as 1Password and synced into clusters through **External Secrets Operator**.  
Only the ESO bootstrap credential may be created manually, and it must never enter Git.
